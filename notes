# main.py - FastAPI сервер для браслета мониторинга походки

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy import create_engine, Column, Integer, Float, DateTime, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel, Field, validator
from typing import List
from datetime import datetime
import logging

# ============================================
# НАСТРОЙКА БАЗЫ ДАННЫХ (SQLAlchemy)
# ============================================

# Для разработки используем SQLite (можно заменить на PostgreSQL)
DATABASE_URL = "sqlite:///./gait_monitoring.db"
# Для продакшн: "postgresql://user:password@localhost/gait_db"

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}  # Только для SQLite
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ============================================
# МОДЕЛЬ БАЗЫ ДАННЫХ (SQLAlchemy)
# ============================================

class IMUDataDB(Base):
    """
    Модель таблицы для хранения данных IMU (Inertial Measurement Unit)
    Каждая строка = один семпл с браслета
    """
    __tablename__ = "imu_data"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String, index=True, nullable=False)  # ID пользователя
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)

    # Данные акселерометра (м/с²)
    accel_x = Column(Float, nullable=False)
    accel_y = Column(Float, nullable=False)
    accel_z = Column(Float, nullable=False)

    # Данные гироскопа (рад/с или град/с)
    gyro_x = Column(Float, nullable=False)
    gyro_y = Column(Float, nullable=False)
    gyro_z = Column(Float, nullable=False)

    # Опционально: магнитометр (если есть в браслете)
    # mag_x = Column(Float, nullable=True)
    # mag_y = Column(Float, nullable=True)
    # mag_z = Column(Float, nullable=True)

# Создаём таблицы в базе данных
Base.metadata.create_all(bind=engine)

# ============================================
# PYDANTIC МОДЕЛИ (Валидация)
# ============================================

class IMUSample(BaseModel):
    """
    Модель для валидации одного семпла от браслета
    Pydantic автоматически проверит типы и диапазоны
    """
    user_id: str = Field(..., min_length=1, max_length=100)
    timestamp: datetime = Field(default_factory=datetime.utcnow)

    # Акселерометр: обычно от -16g до +16g (где g = 9.81 м/с²)
    accel_x: float = Field(..., ge=-200.0, le=200.0)
    accel_y: float = Field(..., ge=-200.0, le=200.0)
    accel_z: float = Field(..., ge=-200.0, le=200.0)

    # Гироскоп: обычно от -2000 до +2000 град/с
    gyro_x: float = Field(..., ge=-3000.0, le=3000.0)
    gyro_y: float = Field(..., ge=-3000.0, le=3000.0)
    gyro_z: float = Field(..., ge=-3000.0, le=3000.0)

    class Config:
        json_schema_extra = {
            "example": {
                "user_id": "user_12345",
                "timestamp": "2025-12-20T10:30:00",
                "accel_x": 0.98,
                "accel_y": 0.15,
                "accel_z": 9.81,
                "gyro_x": 0.5,
                "gyro_y": -1.2,
                "gyro_z": 0.3
            }
        }

class IMUBatchRequest(BaseModel):
    """
    Модель для батча семплов (обычно 50 штук за раз)
    """
    samples: List[IMUSample] = Field(..., min_items=1, max_items=100)

    @validator('samples')
    def check_user_consistency(cls, samples):
        """Проверяем, что все семплы от одного пользователя"""
        if len(samples) > 1:
            first_user = samples[0].user_id
            if not all(s.user_id == first_user for s in samples):
                raise ValueError("Все семплы должны быть от одного пользователя")
        return samples

class IMUBatchResponse(BaseModel):
    """Ответ после успешной записи"""
    success: bool
    samples_saved: int
    message: str

# ============================================
# DEPENDENCY: Получение сессии БД
# ============================================

def get_db():
    """Dependency для получения сессии базы данных"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ============================================
# FASTAPI ПРИЛОЖЕНИЕ
# ============================================

app = FastAPI(
    title="Gait Monitoring API",
    description="API для приёма данных с браслета мониторинга походки",
    version="1.0.0"
)

# CORS для фронтенда (если нужно)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # В продакшне указать конкретные домены
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Логирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================
# ENDPOINTS
# ============================================

@app.get("/")
def root():
    """Проверка работоспособности API"""
    return {
        "message": "Gait Monitoring API работает",
        "version": "1.0.0",
        "endpoints": {
            "POST /api/imu/batch": "Отправить батч IMU данных",
            "GET /api/imu/stats": "Получить статистику"
        }
    }

@app.post(
    "/api/imu/batch",
    response_model=IMUBatchResponse,
    status_code=status.HTTP_201_CREATED
)
def save_imu_batch(
    batch: IMUBatchRequest,
    db: Session = Depends(get_db)
):
    """
    Основной endpoint для приёма данных с браслета

    Процесс:
    1. Pydantic валидирует JSON (автоматически)
    2. Конвертируем Pydantic модели в SQLAlchemy модели
    3. Bulk insert в базу данных
    4. Возвращаем результат
    """
    try:
        logger.info(f"Получен батч из {len(batch.samples)} семплов от {batch.samples[0].user_id}")

        # Шаг 2: Преобразование Pydantic → SQLAlchemy
        db_samples = [
            IMUDataDB(
                user_id=sample.user_id,
                timestamp=sample.timestamp,
                accel_x=sample.accel_x,
                accel_y=sample.accel_y,
                accel_z=sample.accel_z,
                gyro_x=sample.gyro_x,
                gyro_y=sample.gyro_y,
                gyro_z=sample.gyro_z
            )
            for sample in batch.samples
        ]

        # Шаг 3: Bulk Insert - САМАЯ ВАЖНАЯ ЧАСТЬ!
        db.add_all(db_samples)  # Добавляем ВСЕ сразу
        db.commit()  # Один коммит для всех

        logger.info(f"Успешно сохранено {len(db_samples)} семплов")

        return IMUBatchResponse(
            success=True,
            samples_saved=len(db_samples),
            message=f"Сохранено {len(db_samples)} семплов"
        )

    except Exception as e:
        db.rollback()  # Откатываем изменения при ошибке
        logger.error(f"Ошибка при сохранении: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Ошибка сохранения данных: {str(e)}"
        )

@app.get("/api/imu/stats")
def get_stats(
    user_id: str = None,
    db: Session = Depends(get_db)
):
    """
    Получить статистику по данным
    """
    try:
        query = db.query(IMUDataDB)

        if user_id:
            query = query.filter(IMUDataDB.user_id == user_id)

        total_samples = query.count()

        if total_samples == 0:
            return {"message": "Нет данных"}

        latest = query.order_by(IMUDataDB.timestamp.desc()).first()
        oldest = query.order_by(IMUDataDB.timestamp.asc()).first()

        return {
            "total_samples": total_samples,
            "user_id": user_id or "все пользователи",
            "oldest_sample": oldest.timestamp if oldest else None,
            "latest_sample": latest.timestamp if latest else None
        }

    except Exception as e:
        logger.error(f"Ошибка получения статистики: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

@app.delete("/api/imu/clear")
def clear_data(
    user_id: str = None,
    confirm: bool = False,
    db: Session = Depends(get_db)
):
    """
    ОПАСНО: Очистить данные (для тестирования)
    Требует confirm=true
    """
    if not confirm:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Добавьте параметр ?confirm=true для подтверждения"
        )

    try:
        query = db.query(IMUDataDB)

        if user_id:
            deleted = query.filter(IMUDataDB.user_id == user_id).delete()
        else:
            deleted = query.delete()

        db.commit()

        return {
            "success": True,
            "deleted_samples": deleted,
            "message": f"Удалено {deleted} записей"
        }

    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )
